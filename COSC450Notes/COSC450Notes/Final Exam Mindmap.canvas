{
	"nodes":[
		{"type":"text","text":" - **Multiprogramming:** multiple jobs are loaded into RAM and run concurrently \n\t- Once CPU became availabale, one job from the ready queue is selected by the short term scheduler\n\t- OS needs to keep each job's current status in process table\n\t- Multiprogramming increases CPU utilization by organizing programs so the CPU always has one to execute\n- **Spooling:** kind of buffering mechanism for a process in which data is temporarily held as a file to be used and executed by a device, program, or system \n- **Time sharing:** multiple terminals are sharing CPU time ","id":"30033eb8d9c6ef7f","x":-175,"y":-2720,"width":455,"height":300,"color":"6"},
		{"type":"text","text":"### **Hardware** \n- **Physical devices:** wires, power supply, IC chips (CPU, memory, I/O)\n- **Micro-architecture:** physical devices that are grouped together to form functional units\n- **Machine language:** executing some set of instructions ","id":"173be80379d31ef4","x":-585,"y":-1510,"width":340,"height":250,"color":"6"},
		{"type":"text","text":"### **A Computer System** \n\n- **Instruction cycle:** the CPU's main task is to execute instructions\n-  **Fetch Cycle:** \n\t- Reading the address of the instruction in PC to be executed from the memory and \n\t-  Loading it into the IR\n\t- PC is modified to point to the next valid instruction\n- **Execute Cycle**:\n\t- Contents of the IR are decoded and executed \n\t- The execution may result in a variety of actions (may be self contained, or involve iteraction with the memory and the ALU)","id":"e8f248bf9fbb6408","x":-1110,"y":-1720,"width":380,"height":420,"color":"6"},
		{"type":"text","text":"### **Computer System Architecture** \n\n- **Modern general-purpose computer system:** one or more CPUs and a number of device controllers connected through a common bus that provides access between I/O devices and shared memory ","id":"7948f3cd039912c6","x":-1110,"y":-1220,"width":380,"height":200,"color":"6"},
		{"type":"text","text":"### **First generation** (1945-1955): \n- Vacuum tubes and plugboards.\n- All programming done in machine language\n","id":"c177bb93d7dedfa9","x":-1045,"y":-2028,"width":250,"height":188,"color":"6"},
		{"type":"text","text":" ### **Fourth generation** (1980 - present): \n - PC build with LSI, VLSI, and ULSI \n - Contains thousands of transistors \n- User types commands from the keyboard\n- Has a GUI","id":"196ae5f6e186ad05","x":-267,"y":-2374,"width":310,"height":216,"color":"6"},
		{"type":"text","text":"### **History of Operating Systems** ","id":"59c39670e4028f54","x":-574,"y":-1968,"width":318,"height":69,"color":"6"},
		{"type":"text","text":"### **Device controller**:  \n\nEach **device controller** is in charge of a specific type of I/O device \n-  Maintains some local buffer storage and a set of special purpose registers \n- Device controller is responsible for moving data between the peripheral devices that it controls and its local buffer storage \n-  Each I/O device has a **device driver** for each device controller ","id":"bb873e598b46590b","x":-615,"y":-1220,"width":400,"height":300,"color":"6"},
		{"type":"text","text":"### **Interrupts:** \n\n- When an I/O device is ready to receive or send data through a bus, it interrupts the OS by sending a signal \n- For I/O, the device driver loads an instruction (read/write) to the device controller's IR\n- The controller starts the transfer of data from the device to its local bugger\n- Once the data transfer is compelte, check any error then the device controller informs the device driver that it is ready to transfer\n- The device driver gives control to the other parts of the OS \n- Hardware may trigger an interrupt at any time by sending a signal\n- Interrupts are a key part of how the OS and hardware interact\n- When the CPU is interrupted, it stops what it is doing and immediately transfers execution to a fixed location where the service routine for the interrupt is located \n- The interrupt service routine executes; on completion, it resumes the interrupted computation\n- The OS holds a table of pointers in low memory for holding addresses of interrupt service routines ","id":"9eb363c7ea8e8125","x":-825,"y":-817,"width":580,"height":465,"color":"6"},
		{"type":"text","text":"### **Memory:** \n- The CPU can load instructions only from RAM\n- **Storage Hierarchy:**\n\t1. Registers in CPU (volatile)\n\t2. Cache memory\n\t3. Main memory - RAM\n\t\t\t1. DRAM (dynamic RAM; capacitors)\n\t\t\t2. SRAM (static RAM; logic gates)\n\t4. Secondary memory (non-volatile)\n\t\t\t1. HDD, SSD, magnetic tape, USB","id":"c0d2f97a75f5eee5","x":-2086,"y":-817,"width":366,"height":320,"color":"6"},
		{"type":"text","text":"### **Components:**\n- ALU, control unit, cache, registers\n- Registers:\n\t- General registers (instruction, data)\n\t- Program counter (address of next instruction - virtual address)\n\t- Stack pointer (address of top of stack for currently running process)\n\t- Program status word (saves control information for each process)\n- The OS must know the content of each register for a process\n- When a process stops running by changing states (from running to ready, running to block), the OS saves content for each register for the process in process table which needs to be used to finish its job","id":"9d5cdff45b7ca1f7","x":-1660,"y":-817,"width":400,"height":450,"color":"6"},
		{"type":"text","text":"### **Input/Output Devices**\n- A large portion of OS code is dedicated to managing I/O\n- Form of interrupt-drive I/O is fine for moving small amounts of data, but has high overhead\n\t- Instead, use DMA (direct memory access) because it can handle I/O independent from the CPU\n\t- The CPU is freed from invovlement with data transfer, so it speeds up the overall computer operation","id":"89a165d6021e9f7e","x":-1225,"y":-732,"width":360,"height":280,"color":"6"},
		{"type":"text","text":"### OS controls all I/O devices by:\n\n1. Issue commands (read/write) to devices \n2. Catch interrupts from devices (when devices are ready to send or receive data)\n3. Handle errors\n- OS provides interface between the devices and the rest of the system ","id":"fa8fd6aa08503dee","x":-1460,"y":-280,"width":340,"height":220,"color":"6"},
		{"type":"text","text":"### Parts of I/O devices: \n1. Mechanical components (device itself)\n2. Electrical components (device controller)\n3. Device driver (software)","id":"19c934eba9c7f3bf","x":-1045,"y":-240,"width":365,"height":140,"color":"6"},
		{"type":"text","text":"### **Serial buses:** \n- Have external ports and a cable that plugs into them to connect to multiple devices\n\t- Disadvantage: slower data communication\n\t- Advantage: long distance communication\n- USB and FireWire","id":"133ca4dc3e2ae45d","x":-1540,"y":-1180,"width":315,"height":240,"color":"6"},
		{"type":"text","text":" ### **Parallel buses:** \n - Use slots on the motherboard and provide multiple lines for data between the CPU and the peripheral card\n\t- Advantage: fast data communication\n\t- Disadvantage: short distance communication due to crosstalk between the parallel line\n- PCI and AGP ","id":"0dbcc6cf0960a1fb","x":-1926,"y":-1180,"width":326,"height":240,"color":"6"},
		{"type":"text","text":"### **Buses:** \n- Common pathway between the CPU and peripheral devices ","id":"48f64f597ac6e8d6","x":-1676,"y":-1336,"width":386,"height":116,"color":"6"},
		{"type":"text","text":"### **CPU**:\n\n- The brain of the computer \n- Each type of CPU has a specific instruction set that can be used for executing each instruction\n- All CPUs contain sets of registers and cache to hold instructions, key variables, and temporary results\n\t- PC, IR, data registers, stack pointer\n- Fecthes instructions from memory and executes them\n- Might have multiple cores","id":"21e65df67ac11ec6","x":-1680,"y":-1675,"width":440,"height":290,"color":"6"},
		{"type":"text","text":"### **Single Processor System:** \n- One CPU with a single processor core\n- **Core:** component that executes instructions and registers for storing data locally; typically capabale of executing a general instruction set\n- May have other special purpose processors, which run on a limited instruction set \n- The OS manages these special purpose processors by sending information about their next task and monitors their status","id":"0ba536fc53afae82","x":-2020,"y":-2020,"width":340,"height":300,"color":"6"},
		{"type":"text","text":"### **Multiprocessor Systems:**\n- Primary advantage: increased throughput. \n\t- The speed up ratio with N processors is less than N, because of overhead due to communicatining with the CPU\n- Definition of multiprocessor also includes multicore systems\n\t- More effecient than multiple chips because on chip communication is faster than between chip ","id":"2330bd10a800649e","x":-1630,"y":-2080,"width":390,"height":280,"color":"6"},
		{"type":"text","text":"### **Second generation** (1945-1965): \n- Transistors and batch system\n- Computers became more reliable\n- Batch system: programmer writes a program on paper, punch program onto cards, bring cards to input room, wait for output\n\t- Two IBM machines (1401 to read cards onto tape, put tape onto 7094 to do computing)","id":"d111a248a0f4cc6d","x":-1045,"y":-2472,"width":320,"height":314,"color":"6"},
		{"type":"text","text":"### **Third generation** (1965-1980): \n- IC and multiprogramming\n-  Maintaining two computer products was expensive\n- IBM System/360 was made for scientific and commericial purposes \n\t- All software, including the OS, had to work on all models \n\t- First major computer to use IC \n- Improve CPU utilization: multiprogramming, spooling, time sharing ","id":"62807ba47218ef8b","x":-680,"y":-2537,"width":370,"height":326,"color":"6"},
		{"type":"text","text":"### **Symmetric Multiprocessing**: \n- Each CPU has its own set of registers and possibly cache memory; each CPU performs all tasks including OS functions and user processes.\n\t- All processors share a common physical memory \n\t- Additional CPUs will increase computing power but the system bus can act as a bottleneck","id":"04ae31f1e099c505","x":-2226,"y":-2392,"width":367,"height":260,"color":"6"},
		{"type":"text","text":"### **Clustered systems**: \n- Two or more individual systems are connected locally and run as one system\n- High availablility service; service will continue if one or more systems fail\n- **Asymmetric clustering**: one machine is on hot stanby - if one node fails, the hot standby host becomes the active server\n- **Symmetric clustering**: two or more hosts are running applications and monitoring eachother; requires more than one application be available to run","id":"2265a3887c63a49c","x":-1445,"y":-2562,"width":335,"height":300,"color":"6"},
		{"type":"text","text":" ### **Non-uniform memory access**: \n - Each CPU has a local memory that is accessed via a small, fast local bus\n- CPUs are connected and share one physical address space\n- Advtange: when a CPU accesses its local memory, its fast with no contention over system interconnect\n- Potential drawback: increased lentecy when a CPU must access remote memory, possible performance penalty","id":"72635461b097e3e6","x":-1820,"y":-2562,"width":340,"height":300,"color":"6"},
		{"type":"text","text":"### **Operating System** \n\nProtected software that provides interface between hardware and software\n\n**Modern complex operating system** has a processor, memory, and I/O devices. ","id":"6b72366d436ee060","x":-585,"y":-1840,"width":340,"height":260,"color":"6"},
		{"type":"text","text":"### **Resources managed:** \n1. Processes\n2. Memory\n3. File\n4. I/O\n5. Deadlock\n","id":"ff694bf839482c44","x":-101,"y":-1180,"width":344,"height":220,"color":"6"},
		{"type":"text","text":"### **Ways to consider the OS:**\n\n - **Extended Machine**: provides an interface between user and hahrdware, computer users can use the hardware (CPU, memory, I/O) without knowing the messy details \n- **Resource Managers**: computer consists of CPU, RAM, and I/O devices","id":"0bd7676e9bf69834","x":-148,"y":-1460,"width":437,"height":240,"color":"6"},
		{"type":"text","text":"### **Von Neumann** \n\n**Von Neumann bottleneck:** limitation on throughput caused by the standard personal computer architecture.\n\nSince processor calculation speeds are much faster than data movement between memory and CPU -- causes a bottleneck\n\nPrograms and data are held in memory; the processor and memory are separate and data moves between the two","id":"3fcb1e3efa19e7d2","x":-59,"y":-2000,"width":437,"height":360,"color":"6"},
		{"type":"text","text":"### **Fifth generation** (1990 - present): \n- mobile computers ","id":"051a69fd6506b393","x":71,"y":-2158,"width":260,"height":124,"color":"6"},
		{"type":"text","text":"### **OS as a Resource Manager** ","id":"454ad3025f1e191f","x":92,"y":-1580,"width":282,"height":76,"color":"6"},
		{"type":"text","text":"### **Process Managment**: \n- The OS is responsible for the following activities for process managment: \n\t1. Creating and deleting both user and system processes\n\t2. Scheduling processes and threads on the CPUs\n\t3. Suspending and resuming processes and threads\n\t4. Providing mechanisms for process synchronization (semaphore, mutex, conditional variable)\n\t5. Providing mechanisms for process communication (PIPE, message queue, shared memory, FIFO, socket)","id":"917a8653323b37ab","x":500,"y":-2420,"width":440,"height":280,"color":"6"},
		{"type":"text","text":"### **Memory Management:** \n- For a program to be executed, it must be mapped to absolute addresses and loaded into memory\n- As the program executes, it accesses program instructions and data from memory by generating them\n- CPU reads instructions from main memory during the instruction-fetch cycle and both reads/writres data from main memory during the data-fetch cycle\n- The OS is responsible for the following activities for memory managment: \n\t1. Keeping trak of what parts of memory are currently being used and which process is using them \n\t2. Allocating and deallocating memory space as needed\n\t3. Deciding which processes (or parts of processes) and data to move in/out of memory","id":"7be86e174808077b","x":1040,"y":-2338,"width":494,"height":396,"color":"6"},
		{"type":"text","text":"### **FIle Mangement**: \n- OS provides a logical, uniform view of information storage for users to save a file\n- The OS implements the abstract concept of a file by managing mass storage media and the devices that control them \n- Files are normally organized into directories to make them easier to use\n- The OS is responsible for the following activities for file management: \n\t1. Creating and deleting files \n\t2. Creating and deleting directories to organize files\n\t3. Supporting primitives for manipulating files and directories \n\t4. Mapping files onto mass sotrage\n\t5. Backing up files on stable (nonvolatile) storage media ","id":"85bc3dc5b2290776","x":1037,"y":-1920,"width":497,"height":364,"color":"6"},
		{"type":"text","text":"### **Mass Storage Management**: \n- Modern computer system use multiple types of secondary storages \n- The OS is responsible for the following activities for secondary storage management\n\t1. Mounting and unmounted\n\t2. Free space managment \n\t3. Storage allocation \n\t4. Disk scheduling \n\t5. Partitioning \n\t6. Protection ","id":"6f00df980e4d4a2b","x":1036,"y":-1540,"width":497,"height":290,"color":"6"},
		{"type":"text","text":"### **Cache Management**\n- Hardware or software component that stores data which might be used against soon\n- Cache hit: the requested data can be found in a cache \n- Cache management is an important design problem\n- The movement of information between levels of a storage hierachy may be either implicit or explicit; depends on hardware diesgn \n\t- Data transfer from cache to CPU and registers is usually a hardware fucntion \n\t- Data transfer from disk to memory is usually controlled by the OS\n\t","id":"24e6963f6533297e","x":1037,"y":-1220,"width":494,"height":290,"color":"6"},
		{"type":"text","text":"### **Four strategies for dealing with deadlock**\n1. Ignore\n2. Detection and recover \n3. Dynamic avoidance by careful allocation\n4. Prevention ","id":"00ff13881c70e394","x":672,"y":-640,"width":320,"height":200,"color":"6"},
		{"type":"text","text":"### **Four necessary conditions to avoid deadlock:**\n1. Mutual exclusion\n2. Circular wait\n3. Hold and wait\n4. No preemptve","id":"356fb0bd3199613c","x":1014,"y":-640,"width":306,"height":200,"color":"6"},
		{"type":"text","text":"### **Deadlock Management** \n- Deadlocks between processes happen since limited number of resources must be shared\n- Processes are sharing resources for finishing their job","id":"bb17c95d8a80813a","x":740,"y":-840,"width":544,"height":120,"color":"6"},
		{"type":"text","text":"### **Input/Output**:\n- OS manages all kinds of I/O devices such as keyboards, monitors, printers\n- I/O subsystems: \n\t- A memory mangement components (buffering, spooling, caching)\n\t- General device drivers\n\t- Drivers for specific hardware\n\t- Processor for specific hardware\n- OS controls I/O devices by:\n\t1. Issue commands to devices \n\t2. Catch interrupts from devices \n\t3. Handle errors","id":"c155ad7bbcb26495","x":319,"y":-1220,"width":421,"height":359,"color":"6"},
		{"type":"text","text":"### **Interrupt Implementation:**\n- Hardware: interrupt-request line that senses after every CPU instruction\n\t- Types: nonmaskable (unrecoverable hardware error) and recoverable (used by device controllers to request service)\n- CPU reads interrupt number and jumps to the routine using the number as an index into the interrupt vector","id":"ffa8250d512db000","x":-615,"y":-240,"width":325,"height":300,"color":"6"},
		{"type":"text","text":"### **Operatng System Structures**","id":"7308375a161cf7ba","x":-101,"y":-792,"width":302,"height":72,"color":"6"},
		{"id":"ccfc64a43c1f863a","x":300,"y":-800,"width":320,"height":260,"color":"6","type":"text","text":"### **Layered Systems:** \n- OS is divided into several layers and each later works on different rules: \n\t1. Layer 0: process management \n\t2. Layer 1: memory management\n\t3. Layer 2: inter-process managment\n\t4. Layer 3: input/output managment \n\t5. Layer 4: user program \n\t6. Layer 5: system operator process"},
		{"id":"d8b6fe09f53c5696","x":300,"y":-520,"width":317,"height":220,"color":"6","type":"text","text":"### **Microkernels**: \n- With the layered approach, the designers have a choice where to draw the kernel-user boundary \n- Achieve high reliability by splitting the OS up into small well-defined module \n- Only one module runs in kernel mode and the rest run as users mode"},
		{"id":"2779120a86f644e2","x":300,"y":-280,"width":320,"height":260,"color":"6","type":"text","text":"### **Virtual Machine**: \n- Runs on bare hardware and does multiprogramming by providing several virtual machines \n\t- Each virtual machine copies the bare heardware, including kernel/user mode, I/O)\n\t- Different VMs can run on different OS"},
		{"type":"text","text":"### **Monolithic**: \n- Written as a collection of procedures, each of which can call any of the others whenever it needs to\n- Each procedure  in the system as a well-defined interface in term of parameters and results, each one is free to call any other one\n- Possible to have some structure for a monolihtic system \n\t- Main program, service functions, utility functions","id":"8e3d944334292d8b","x":-245,"y":-300,"width":386,"height":300,"color":"6"},
		{"id":"a24f7daff27619c5","x":-1720,"y":80,"width":260,"height":100,"color":"2","type":"text","text":"### **Process**: \n- Program in execution"},
		{"id":"2d42fd49234276dd","x":-1300,"y":-15,"width":475,"height":290,"color":"2","type":"text","text":"### **The Process Model**: \n- **Real model**: multiprogramming \n- **Conceptual (virtual) model**: each process has its own virtual CPU (ALU, PC, registers, stack pointer) and RAM\n\t- Virtual Machine: each OS runs its own machine\n\t- Virtual Memory: each process has  its own memory\n\t- Virtual process model: each process runs on its own machine\n- A process can hold CPU during its time term (amount of time allocated to process, not uniform)\n- Time term might be calculated based on the type of jobs (I/O bounded, CPU bounded, or priority)"},
		{"id":"7456492efb2e53a7","x":-2360,"y":-468,"width":380,"height":262,"color":"2","type":"text","text":"**When a process creates a new process, two possibilities for execution exist:** \n- The parent continues to execute concurrently with its children by using waitpid()\n- The parent waits for some or all of its children to finish executing by wait() \n- Two address-space possibilities: \n\t- The child is a duplicate of the parent process\n\t- Child process has a new program loaded using exec into it and run "},
		{"id":"c37fa5fb8e6df643","x":-2108,"y":-120,"width":345,"height":200,"color":"2","type":"text","text":" ### **Process Creation**:\n1. System initialization: when an OS is booted\n2. Created by a running process using a system call\n3. Created by system user by executing a program\n4. Initiation of a batch job"},
		{"id":"ea0dbe3c002e5699","x":-2572,"y":-40,"width":425,"height":300,"color":"2","type":"text","text":"### **Process Termination**\n- Process may terminate due to the following conditions:\n- **Voluntary**:\n\t- Normal exit (process finishes its job)\n\t- Error exit (process itself discoveres a fatal error)\n- **Involuntary**:\n\t- Fatal error (error cauzed by the process)\n\t- Killed by another process (when a deadlock is discovered)\n- **Zombie process**: process that has terminated, but whose parent has not yet called wait()"},
		{"id":"197d03987096dd3f","x":-2572,"y":580,"width":313,"height":270,"color":"2","type":"text","text":"### **Process Table**: \n- When a process is created, the OS stores its run time information in a process table\n- Contains process state, program counter, contents of CPU registers, CPU scheduling information, memory management information, accounting information, and I/O status "},
		{"id":"c816474674b5a16e","x":-2567,"y":300,"width":308,"height":220,"color":"2","type":"text","text":"### **Process States**: \n- **Running state:** process is currently being executed by using the CPU\n- **Block state**: process is waiting for some event to occur (I/O, signal)\n- **Ready state**: process is ready to use CPU but it is not currently available "},
		{"id":"06a8ed4efda0d91d","x":-1720,"y":850,"width":299,"height":230,"color":"2","type":"text","text":"- When the CPU becomes available, the short term scheduler seelcts a process from the ready queue\n- Two types of queues to hold pointers to process tables for processes in the block and ready state: \n\t- **Ready queue** and **wait queue** \n\t- Generally stored as a linked list"},
		{"id":"46bc804bcc8f0736","x":-2615,"y":910,"width":400,"height":260,"color":"2","type":"text","text":" **Events that can occur once a CPU is allocated and executing:** \n1. Process could request I/O and be placed in an I/O wait queue\n2. Process could create a new child process then be placed into wait queue \n3. Process could be forcibly removed as the result of an interrupt\n4. Process could try and a down semaphore whose value is 0, be placed into semaphore wait queue"},
		{"id":"dec0ba306ac91759","x":-2060,"y":990,"width":290,"height":180,"color":"2","type":"text","text":"### **Scheduling Algorithm**s \n\nShortest job first, shortest remaining time, round robin, priority queue, guaranteed scheduling, lottery scheduling "},
		{"id":"181af7c9c22a3352","x":-2025,"y":575,"width":220,"height":80,"color":"2","type":"text","text":" ### **Process Scheduling** "},
		{"id":"87c7e177970ce3da","x":-1751,"y":310,"width":330,"height":200,"color":"2","type":"text","text":"### **Memory layout of a process**: \n1. Text section (executable code)\n2. Data section (global variables)\n3. Heap (used for dynamic allocation)\n4. Stack section (temporary data storage for local variables - function parameters, return addresses, local variables)"},
		{"id":"989e22512716837f","x":-1720,"y":585,"width":299,"height":235,"color":"2","type":"text","text":"### **Context Switch**: \n- Interrupts cause the OS to change a CPU from the current task to run a kernel routine through a context switch, which is performing a state save of the current process and a state load of a process from its process table\n- Pure overhead (CPU must be idle)"},
		{"id":"8cb1ad38a8c2ac2a","x":-1266,"y":410,"width":408,"height":240,"color":"2","type":"text","text":"### **The Process:** \n- Assuming that we have one CPU (single core) in the system \n- **Multiprogramming**: several jobs are loaded into memory, OS simulates pseudo parallelism through virtual memory\n- The OS schedules CPU time for processes by switching from one process to another based on the *scheduling algorithm* and *process state*"},
		{"id":"d10bbeee5b04117f","x":-1266,"y":703,"width":306,"height":57,"color":"3","type":"text","text":"### **Interprocess Communication** "},
		{"id":"b3b3c6c177c0efd0","x":-1380,"y":850,"width":301,"height":170,"color":"3","type":"text","text":"### **Reasons for allowing process cooperation:**\n\n1. Information sharing\n2. Computational speed up\n3. Modularity "},
		{"id":"882fb226859c4eaf","x":-825,"y":682,"width":288,"height":100,"color":"3","type":"text","text":"### **Fundamental models of interprocess communication**"},
		{"id":"15b251a0d361c5b5","x":-1020,"y":850,"width":339,"height":370,"color":"3","type":"text","text":"### **Shared memory**\n\n- Region of memory is shared, OS is only involved in creation but not in synchronization/mutual exclusion\n- Faster than message passing, since shared memory is in user's space after the initial set-up system calls\n- All memory accesses are treated as routine memory accesses, without kernel's assistance; allows processes to access each other's memory without the OS getting involved\n- Other processes that wish to use the shared-memory segment must attach it to their address spaces by key values "},
		{"id":"77adca991cd026c0","x":-1020,"y":1280,"width":339,"height":260,"color":"3","type":"text","text":"### **Producer-Consumer Problem with Shared Memory**\n\n- Has a buffer of items that can be refilled by producer and emptied by consumer\n- Buffer resides in shared memory\n- Producer/consumer must be synchronized so the producer doesn't try and overfill the buffer and the consumer doesn't try to consumer from an empty buffer"},
		{"id":"a07623a84b521994","x":-640,"y":850,"width":360,"height":290,"color":"3","type":"text","text":"### **Message passing**\n\n- Communication takes place by means of messages exchanged, easy to implement in large systems, OS involved with creation and synchronization \n- Message queue, FIFO, socket \n- Allows processes to communicate and synchronize their actions without sharing the same address space\n- A communication link must exist between the processes"},
		{"id":"3c6211000b42027c","x":-648,"y":1233,"width":348,"height":355,"color":"3","type":"text","text":"### **Indirect and Direct Communication** \n\n- Direct communication requires each process to know the end point address for sending/receiving messages, while with indirect communication, messages are sent/received from mailboxes\n- Direct communication can be full duplex (both processes have endpoint addresses) or half duplex (send to specific address, receive from any)\n- Indirect communication allows a process to communicate with another process via a bunch of different mailboxes, but two processes can only communicate if they have a shared mailbox"},
		{"id":"b66b6e7597e240ca","x":-280,"y":1273,"width":300,"height":267,"color":"3","type":"text","text":"### **Synchronization**\n\n- Can be blocking (synchronous - sender/receiver are blocked until message is received/sent) or nonblocking (asynchronous - sender sends message then continues and receiver either receives a valid or null message)\n\t- Rendezvous: both sender and receiver are blocking"},
		{"id":"c11ce8a14b33c78e","x":-200,"y":920,"width":250,"height":260,"color":"3","type":"text","text":"### **Buffering** \n\n- Zero capacity (no messages are queued on a link)\n- Bounded capacity (finite length of n messages)\n- Unbounded capacity (infinite length)"},
		{"id":"12ab39668f4804a1","x":-1860,"y":-337,"width":320,"height":147,"color":"2","type":"text","text":"### **Child processes:** \n- Once a child process is created, both parent and child have their own distinct address, requiring inter-process communication for sharing resources. "},
		{"id":"245094c19fe30d22","x":-830,"y":390,"width":305,"height":260,"color":"1","type":"text","text":"Each thread runs on a different part of a process.\n- Thread ID\n- Program Counter\n- Register set\n- Stack \n- Shares with other threads belonging to the same process its code section, data section, and OS resources, such as open files and signals "},
		{"id":"d2d12235a89d2b56","x":-460,"y":422,"width":440,"height":360,"color":"1","type":"text","text":"### **Multicore Programming with Threads**\n\n- Provides improved concurrency \n- Challenges for programming in multicore systems: \n\t1. Identifiying tasks\n\t2. Balance (balanced worked load)\n\t3. Data splitting (data is accessed and manipulated into separate tasks)\n\t4. Data dependency \n\t5. Testing and debugging \n-  Types of parallelism \n\t1. Data parallelism (distributing subsets of the same data across multiple computing cores)\n\t2. Task parallelism (distributing tasks/threads across multiple computing cores)"},
		{"id":"2a7d4faf15cc1db5","x":-681,"y":155,"width":125,"height":50,"color":"1","type":"text","text":"### **Threads** "},
		{"id":"8f04b6e529db81ac","x":-172,"y":25,"width":472,"height":260,"color":"1","type":"text","text":"**Benefits with Threads**: \n- Resource sharing (share memory and resources of the process that they belong too; allows an application to have several different threads of activity within the same address space)\n- Economy (more economical to create and context-switch threads)\n- Responsiveness (program may continue to run even if part of a program which is run by a thread is blocked)\n- Scalability (benefits are even greater in a multiprocessor architecture)"},
		{"id":"e26b2fa5dcbfb124","x":16,"y":552,"width":284,"height":268,"color":"1","type":"text","text":"### **Advantages**:\n1. Thread switching does not requre kernel mode privileges \n2. User level threads can run on any OS\n3. Scheduling can be application specific in user level threads\n4. User level threads are fast to create and manage"},
		{"id":"8c4828c6b4a795ba","x":337,"y":592,"width":245,"height":180,"color":"1","type":"text","text":"**Disadvantages**:\n1. Most system calls are blocked \n2. Multithreaded applications cannot take advantage of multiprocessing"},
		{"id":"c631343d6f96054e","x":141,"y":305,"width":310,"height":170,"color":"1","type":"text","text":"### **User Level Threads** \n\n- Kernel is not aware of threads \n- Thread library controls creations, destruction and scheduling \n- Application starts with single thread"},
		{"id":"bfc9737057db5757","x":418,"y":25,"width":328,"height":240,"color":"1","type":"text","text":"### **Kernel Level Threads** \n\n- Thread managment is done by OS\n- Kernel maintains context information for the process as a whole\n- Scheduling by the kernel is done on a thread basis \n- Kernel performs thread creation, scheduling, and management in kernel space"},
		{"id":"ba36a644bc8403c4","x":832,"y":-137,"width":300,"height":235,"color":"1","type":"text","text":"### **Advantages**: \n1. Kernel can schedule multiple threads from the same process on multiple processes\n2. If one thread on a process is blocked, the kernel can schedule another thread on the same process\n3. Kernel routines themselves can be multithreaded"},
		{"id":"23ed76e26ea2b1b5","x":832,"y":160,"width":300,"height":210,"color":"1","type":"text","text":"### **Disadvantages**\n1. Kernel threads are general slower to create and manage than the user threads\n2. Transfer of control from one thread to another within the same process requires a mode switch "},
		{"id":"51f82f0a03771482","x":620,"y":415,"width":240,"height":60,"color":"1","type":"text","text":"### **Multithreading Models** "},
		{"id":"5cbce5b347295af7","x":1000,"y":415,"width":338,"height":246,"color":"1","type":"text","text":"### **One to One** \n\n- Maps each user thread to a kernel thread \n- More concurrency than many-to-one model by allowing another thread to run when a thread makes a blocking system call \n- Allows multiple threads to run in parallel\n- A large number of kernel threads may burden the performance of a system "},
		{"id":"3f0bd4958b431a85","x":594,"y":643,"width":305,"height":297,"color":"1","type":"text","text":"### **Many to One**\n\n- Maps many user-level threads to one kernel threads\n- Thread managment is done by the thread library is user space, efficient \n- When a thread makes a blocking system call, the entire process will be blocked \n- Only one thread can access the kernel at a time, multiple threads are unable to run in parallel on multiprocessors "},
		{"id":"bdfe32c1b95f4659","x":982,"y":722,"width":398,"height":218,"color":"1","type":"text","text":"### **Many to Many**\n\n- Multiplexes any number of user threads onto an equal or small number of kernel threads \n- Allows developers to create as many user threads as needed\n- Provides best accuracy on concurrency and when a thread performs a blocking call, the kernel can schedule another thread for execution "},
		{"type":"text","text":"###  **Basic instruction cycle executed by CPU:**\n1. Fetch data from memory to register\n2. Decode the instruction\n3. Execute the instruction","id":"df02f6fff9222ac6","x":-2066,"y":-1436,"width":280,"height":200,"color":"6"},
		{"id":"202c2d04f072c51b","x":-2280,"y":-1557,"width":266,"height":55,"color":"5","type":"text","text":"### **CPU Scheduling**"},
		{"id":"b3e61ef0a3b1d538","x":-2525,"y":-1870,"width":439,"height":200,"color":"5","type":"text","text":" ### **Three Levels of Schedulers** \n - **Long Term Scheduler**: selects a process from the job queue and loads it into memory for execution \n- **Short Term Scheduler**: selects a process from the ready queue and allocates it to the CPU\n- **Memory Scheduler**: schedules which process is in memory and in disk"}
	],
	"edges":[
		{"id":"8e63519f340580f7","fromNode":"6b72366d436ee060","fromSide":"bottom","toNode":"173be80379d31ef4","toSide":"top"},
		{"id":"65137739aa6d2594","fromNode":"6b72366d436ee060","fromSide":"right","toNode":"3fcb1e3efa19e7d2","toSide":"left"},
		{"id":"759589d562d74400","fromNode":"6b72366d436ee060","fromSide":"right","toNode":"0bd7676e9bf69834","toSide":"left"},
		{"id":"c5c28631aa218f75","fromNode":"0bd7676e9bf69834","fromSide":"bottom","toNode":"ff694bf839482c44","toSide":"top"},
		{"id":"9a8574000f6a033c","fromNode":"59c39670e4028f54","fromSide":"bottom","toNode":"6b72366d436ee060","toSide":"top"},
		{"id":"f0e619a7c3537146","fromNode":"59c39670e4028f54","fromSide":"left","toNode":"c177bb93d7dedfa9","toSide":"bottom"},
		{"id":"de423d480b8b7750","fromNode":"59c39670e4028f54","fromSide":"top","toNode":"d111a248a0f4cc6d","toSide":"bottom"},
		{"id":"8a3f9300ff4a5bf5","fromNode":"59c39670e4028f54","fromSide":"top","toNode":"62807ba47218ef8b","toSide":"bottom"},
		{"id":"dae864ff3a8f562e","fromNode":"59c39670e4028f54","fromSide":"top","toNode":"196ae5f6e186ad05","toSide":"bottom"},
		{"id":"53c0f77d2f7a999a","fromNode":"59c39670e4028f54","fromSide":"right","toNode":"051a69fd6506b393","toSide":"left"},
		{"id":"b4677b6a57218a00","fromNode":"62807ba47218ef8b","fromSide":"right","toNode":"30033eb8d9c6ef7f","toSide":"left"},
		{"id":"9aa97f09de4b50d1","fromNode":"6b72366d436ee060","fromSide":"left","toNode":"e8f248bf9fbb6408","toSide":"right"},
		{"id":"9784a6b592e44e06","fromNode":"e8f248bf9fbb6408","fromSide":"bottom","toNode":"7948f3cd039912c6","toSide":"top"},
		{"id":"e677e25461923fc5","fromNode":"7948f3cd039912c6","fromSide":"right","toNode":"bb873e598b46590b","toSide":"left"},
		{"id":"47dc11bd2a475a89","fromNode":"7948f3cd039912c6","fromSide":"left","toNode":"21e65df67ac11ec6","toSide":"right"},
		{"id":"f983e271cef6bc46","fromNode":"7948f3cd039912c6","fromSide":"bottom","toNode":"9d5cdff45b7ca1f7","toSide":"top"},
		{"id":"75e88734748ce3fb","fromNode":"7948f3cd039912c6","fromSide":"bottom","toNode":"9eb363c7ea8e8125","toSide":"top"},
		{"id":"dfe44a03f0016af5","fromNode":"7948f3cd039912c6","fromSide":"bottom","toNode":"c0d2f97a75f5eee5","toSide":"top"},
		{"id":"cecdf60de86981ee","fromNode":"21e65df67ac11ec6","fromSide":"left","toNode":"df02f6fff9222ac6","toSide":"right"},
		{"id":"ae281fe69da91b77","fromNode":"7948f3cd039912c6","fromSide":"bottom","toNode":"89a165d6021e9f7e","toSide":"top"},
		{"id":"b73697ec98828a4f","fromNode":"89a165d6021e9f7e","fromSide":"bottom","toNode":"fa8fd6aa08503dee","toSide":"top"},
		{"id":"36dc1628b4c4e3e0","fromNode":"89a165d6021e9f7e","fromSide":"bottom","toNode":"19c934eba9c7f3bf","toSide":"top"},
		{"id":"3454134995d623d1","fromNode":"7948f3cd039912c6","fromSide":"left","toNode":"48f64f597ac6e8d6","toSide":"right"},
		{"id":"4be9037afff32b6d","fromNode":"48f64f597ac6e8d6","fromSide":"left","toNode":"0dbcc6cf0960a1fb","toSide":"top"},
		{"id":"a7b398c972f2c10e","fromNode":"48f64f597ac6e8d6","fromSide":"bottom","toNode":"133ca4dc3e2ae45d","toSide":"top"},
		{"id":"838608611a836387","fromNode":"21e65df67ac11ec6","fromSide":"top","toNode":"0ba536fc53afae82","toSide":"bottom"},
		{"id":"e1c5e608282e014b","fromNode":"21e65df67ac11ec6","fromSide":"top","toNode":"2330bd10a800649e","toSide":"bottom"},
		{"id":"d6942bf6ffc35e1e","fromNode":"2330bd10a800649e","fromSide":"top","toNode":"04ae31f1e099c505","toSide":"bottom"},
		{"id":"aa62ddb7284f53d4","fromNode":"2330bd10a800649e","fromSide":"top","toNode":"72635461b097e3e6","toSide":"bottom"},
		{"id":"0bc18c88cbab0221","fromNode":"2330bd10a800649e","fromSide":"top","toNode":"2265a3887c63a49c","toSide":"bottom"},
		{"id":"63c04133dfd05818","fromNode":"6b72366d436ee060","fromSide":"right","toNode":"454ad3025f1e191f","toSide":"left"},
		{"id":"c31115d144653340","fromNode":"454ad3025f1e191f","fromSide":"right","toNode":"917a8653323b37ab","toSide":"left"},
		{"id":"3cc8566d6abb8b95","fromNode":"454ad3025f1e191f","fromSide":"right","toNode":"7be86e174808077b","toSide":"left"},
		{"id":"60e29a7eda29be11","fromNode":"454ad3025f1e191f","fromSide":"right","toNode":"85bc3dc5b2290776","toSide":"left"},
		{"id":"638269bbc246325f","fromNode":"454ad3025f1e191f","fromSide":"right","toNode":"6f00df980e4d4a2b","toSide":"left"},
		{"id":"aeed94a186d8d151","fromNode":"454ad3025f1e191f","fromSide":"right","toNode":"24e6963f6533297e","toSide":"left"},
		{"id":"5b2d22926dfa7d3a","fromNode":"454ad3025f1e191f","fromSide":"right","toNode":"bb17c95d8a80813a","toSide":"top"},
		{"id":"2c2b594e8c3aeb79","fromNode":"bb17c95d8a80813a","fromSide":"bottom","toNode":"00ff13881c70e394","toSide":"top"},
		{"id":"a2fee3c08edc4599","fromNode":"bb17c95d8a80813a","fromSide":"bottom","toNode":"356fb0bd3199613c","toSide":"top"},
		{"id":"f7e84e65186b0ea3","fromNode":"454ad3025f1e191f","fromSide":"right","toNode":"c155ad7bbcb26495","toSide":"top"},
		{"id":"ec817f6f7f9f0582","fromNode":"9eb363c7ea8e8125","fromSide":"bottom","toNode":"ffa8250d512db000","toSide":"top"},
		{"id":"5871dd8d3ee2b0ee","fromNode":"6b72366d436ee060","fromSide":"right","toNode":"7308375a161cf7ba","toSide":"left"},
		{"id":"31990ca747e44eb1","fromNode":"7308375a161cf7ba","fromSide":"bottom","toNode":"8e3d944334292d8b","toSide":"top"},
		{"id":"cbfc65d6c6703888","fromNode":"7308375a161cf7ba","fromSide":"right","toNode":"ccfc64a43c1f863a","toSide":"left"},
		{"id":"c3c55a2cccb4bafb","fromNode":"7308375a161cf7ba","fromSide":"bottom","toNode":"d8b6fe09f53c5696","toSide":"left"},
		{"id":"84c987f3c90a79f5","fromNode":"7308375a161cf7ba","fromSide":"bottom","toNode":"2779120a86f644e2","toSide":"left"},
		{"id":"94bc47e0b950a08f","fromNode":"a24f7daff27619c5","fromSide":"bottom","toNode":"87c7e177970ce3da","toSide":"top"},
		{"id":"4a647b79a52319d3","fromNode":"a24f7daff27619c5","fromSide":"bottom","toNode":"8cb1ad38a8c2ac2a","toSide":"top"},
		{"id":"4e03c46463249f56","fromNode":"a24f7daff27619c5","fromSide":"right","toNode":"2d42fd49234276dd","toSide":"left"},
		{"id":"01e938c9b177aeba","fromNode":"a24f7daff27619c5","fromSide":"top","toNode":"c37fa5fb8e6df643","toSide":"right"},
		{"id":"19d29b5e8db12734","fromNode":"c37fa5fb8e6df643","fromSide":"top","toNode":"12ab39668f4804a1","toSide":"bottom"},
		{"id":"27d77cce66d626ef","fromNode":"c37fa5fb8e6df643","fromSide":"top","toNode":"7456492efb2e53a7","toSide":"bottom"},
		{"id":"09f8bd9777185f77","fromNode":"a24f7daff27619c5","fromSide":"left","toNode":"ea0dbe3c002e5699","toSide":"right"},
		{"id":"a5b6855c06cf1f56","fromNode":"a24f7daff27619c5","fromSide":"left","toNode":"c816474674b5a16e","toSide":"right"},
		{"id":"c809c59ab8277c0e","fromNode":"a24f7daff27619c5","fromSide":"left","toNode":"197d03987096dd3f","toSide":"right"},
		{"id":"2b0b950c2af872bb","fromNode":"a24f7daff27619c5","fromSide":"left","toNode":"181af7c9c22a3352","toSide":"top"},
		{"id":"8206c88e1c966528","fromNode":"181af7c9c22a3352","fromSide":"bottom","toNode":"dec0ba306ac91759","toSide":"top"},
		{"id":"c49036734ab59582","fromNode":"181af7c9c22a3352","fromSide":"bottom","toNode":"06a8ed4efda0d91d","toSide":"left"},
		{"id":"6dca06909ac21994","fromNode":"181af7c9c22a3352","fromSide":"bottom","toNode":"46bc804bcc8f0736","toSide":"right"},
		{"id":"e46521f30babc991","fromNode":"a24f7daff27619c5","fromSide":"right","toNode":"d10bbeee5b04117f","toSide":"left"},
		{"id":"67106168f3ec3b6d","fromNode":"d10bbeee5b04117f","fromSide":"bottom","toNode":"b3b3c6c177c0efd0","toSide":"top"},
		{"id":"fcfa7d5cb8304362","fromNode":"d10bbeee5b04117f","fromSide":"right","toNode":"882fb226859c4eaf","toSide":"left"},
		{"id":"b8fc4c1ae700180e","fromNode":"882fb226859c4eaf","fromSide":"bottom","toNode":"15b251a0d361c5b5","toSide":"top"},
		{"id":"e6e819796bb237b8","fromNode":"15b251a0d361c5b5","fromSide":"bottom","toNode":"77adca991cd026c0","toSide":"top"},
		{"id":"616869cb5efa39c8","fromNode":"882fb226859c4eaf","fromSide":"bottom","toNode":"a07623a84b521994","toSide":"top"},
		{"id":"f4485d63eb39ac7c","fromNode":"a07623a84b521994","fromSide":"bottom","toNode":"3c6211000b42027c","toSide":"top"},
		{"id":"7fca475be88a8e2e","fromNode":"a07623a84b521994","fromSide":"bottom","toNode":"b66b6e7597e240ca","toSide":"top"},
		{"id":"ec315b41da82fcce","fromNode":"a07623a84b521994","fromSide":"right","toNode":"c11ce8a14b33c78e","toSide":"left"},
		{"id":"f84b945eb6ae3517","fromNode":"2a7d4faf15cc1db5","fromSide":"bottom","toNode":"245094c19fe30d22","toSide":"top"},
		{"id":"14a2a65fb0d9139f","fromNode":"2a7d4faf15cc1db5","fromSide":"right","toNode":"8f04b6e529db81ac","toSide":"left"},
		{"id":"85bf46fad7af6cb3","fromNode":"2a7d4faf15cc1db5","fromSide":"bottom","toNode":"d2d12235a89d2b56","toSide":"top"},
		{"id":"87b0d3bea90a37a8","fromNode":"2a7d4faf15cc1db5","fromSide":"right","toNode":"c631343d6f96054e","toSide":"left"},
		{"id":"54dfb54f6742813c","fromNode":"c631343d6f96054e","fromSide":"bottom","toNode":"e26b2fa5dcbfb124","toSide":"top"},
		{"id":"2d80f63855dfd78d","fromNode":"c631343d6f96054e","fromSide":"bottom","toNode":"8c4828c6b4a795ba","toSide":"top"},
		{"id":"e5640bffd4530bee","fromNode":"2a7d4faf15cc1db5","fromSide":"right","toNode":"bfc9737057db5757","toSide":"left"},
		{"id":"4f58938b4c1cb171","fromNode":"bfc9737057db5757","fromSide":"right","toNode":"ba36a644bc8403c4","toSide":"left"},
		{"id":"be29c4f2d2a0b894","fromNode":"bfc9737057db5757","fromSide":"right","toNode":"23ed76e26ea2b1b5","toSide":"left"},
		{"id":"f3b0d0ee3edbae8c","fromNode":"bfc9737057db5757","fromSide":"bottom","toNode":"51f82f0a03771482","toSide":"left"},
		{"id":"3443c9cd35bb9739","fromNode":"c631343d6f96054e","fromSide":"right","toNode":"51f82f0a03771482","toSide":"left"},
		{"id":"42edeb3132a86cce","fromNode":"51f82f0a03771482","fromSide":"bottom","toNode":"3f0bd4958b431a85","toSide":"top"},
		{"id":"aac30e295c89125b","fromNode":"51f82f0a03771482","fromSide":"right","toNode":"5cbce5b347295af7","toSide":"left"},
		{"id":"1fcdfcba37d7fdf6","fromNode":"51f82f0a03771482","fromSide":"right","toNode":"bdfe32c1b95f4659","toSide":"left"},
		{"id":"1bfe9afd9b05a2d5","fromNode":"21e65df67ac11ec6","fromSide":"left","toNode":"202c2d04f072c51b","toSide":"right"},
		{"id":"4b8f9726767d8ed6","fromNode":"202c2d04f072c51b","fromSide":"top","toNode":"b3e61ef0a3b1d538","toSide":"bottom"}
	]
}